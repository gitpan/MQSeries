    <HTML> 
	<HEAD> 
	    <TITLE>Changes.src</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#Introduction">Introduction</A>
	<LI><A HREF="#Changes_for_1_12">Changes for 1.12</A>
	<UL>

		<LI><A HREF="#MQSeries_Command_Responses">MQSeries::Command->Responses</A>
		<LI><A HREF="#Support_for_control_of_implicitl">Support for control of implicitly commited transactions</A>
		<LI><A HREF="#MQSeries_QueueManager_Connect_">MQSeries::QueueManager->Connect() timeout logic</A>
		<LI><A HREF="#OS_390_Support">OS/390 Support</A>
		<LI><A HREF="#MQSeries_Config_Authority">MQSeries::Config::Authority</A>
		<LI><A HREF="#MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject fix: Change, not Create</A>
		<LI><A HREF="#MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject fix: Comparing lists</A>
		<LI><A HREF="#Limit_the_max_of_open_files_fo">Limit the max # of open files for MQSeries::FDC::Tail</A>
		<LI><A HREF="#Support_for_symbolic_Wait_and_Ex">Support for symbolic Wait and Expiry values</A>
		<LI><A HREF="#Use_of_GetConvert_error_checke">Use of GetConvert() error checked properly</A>
		<LI><A HREF="#GetConvertReason_and_PutConver">GetConvertReason() and PutConvertReason() methods added</A>
		<LI><A HREF="#MQSeries_Command_Support_for_o">MQSeries::Command: Support for ordered attributes</A>
	</UL>

	<LI><A HREF="#Changes_for_1_11">Changes for 1.11</A>
	<UL>

		<LI><A HREF="#MQSeries_Config_classes">MQSeries::Config::* classes</A>
		<LI><A HREF="#MQSeries_ErrorLog_classes">MQSeries::ErrorLog::* classes</A>
		<LI><A HREF="#MQSeries_FDC_classes">MQSeries::FDC::* classes</A>
		<LI><A HREF="#MQSeries_Message_DeadLetter_ob">MQSeries::Message::DeadLetter object</A>
		<LI><A HREF="#Use_of_PutConvert_error_checke">Use of PutConvert() error checked properly</A>
		<LI><A HREF="#MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject method handles lists correctly</A>
		<LI><A HREF="#All_GetConvert_methods_save_ra">All GetConvert() methods save raw Buffer</A>
		<LI><A HREF="#MQSeries_PubSub_ModelQName_">MQSeries::PubSub::*, ModelQName DynamicQName configurable</A>
		<LI><A HREF="#MQSeries_PubSub_AdminMessage_">MQSeries::PubSub::AdminMessage->_TranslatePCF</A>
		<LI><A HREF="#MQSeries_Queue_Open_was_sile">MQSeries::Queue->Open() was silent on non-retried errors</A>
	</UL>

	<LI><A HREF="#Changes_for_1_10">Changes for 1.10</A>
	<UL>

		<LI><A HREF="#MQSeries_Command_MQSC_bugs">MQSeries::Command MQSC bugs</A>
		<LI><A HREF="#MQSeries_Message_allows_BufferL">MQSeries::Message allows BufferLength of 0</A>
		<LI><A HREF="#MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject enhancements and documentation</A>
	</UL>

	<LI><A HREF="#Changes_for_1_09">Changes for 1.09</A>
	<UL>

		<LI><A HREF="#Support_for_Win32">Support for Win32</A>
		<LI><A HREF="#Retry_logic_in_MQSeries_QueueMa">Retry logic in MQSeries::QueueManager->Connect() and MQSeries::Queue->Open()</A>
		<LI><A HREF="#MQSeries_Command_new_takes_add">MQSeries::Command->new takes additional arguments.</A>
		<LI><A HREF="#MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject() method added</A>
		<LI><A HREF="#MQSeries_QueueManager_Hconn_ref">MQSeries::QueueManager Hconn reference counting</A>
		<LI><A HREF="#MQSeries_QueueManager_construct">MQSeries::QueueManager constructor arguments</A>
		<LI><A HREF="#MQSeries_Queue_Open_ignores_">MQSeries::Queue->Open() ignores the Hobj on errors</A>
		<LI><A HREF="#MQSeries_Message_Buffer_meth">MQSeries::Message->Buffer() method added</A>
		<LI><A HREF="#MQSeries_Message_Event_GetCon">MQSeries::Message::Event->GetConvert() saves raw Buffer</A>
	</UL>

	<LI><A HREF="#Changes_for_1_08">Changes for 1.08</A>
	<UL>

		<LI><A HREF="#MQSeries_Message_Event_was_bro">MQSeries::Message::Event was broken</A>
		<LI><A HREF="#MQSeries_Command_error_checking">MQSeries::Command error checking enhancement</A>
		<LI><A HREF="#MQSeries_QueueManager_and_MQSer">MQSeries::QueueManager and MQSeries::Queue constructor bug</A>
		<LI><A HREF="#MQSeries_Queue_Put_method_wa">MQSeries::Queue->Put() method wasn't setting MQPMO_FAIL_IF_QUIESCING</A>
		<LI><A HREF="#MQSeries_PubSub_Broker_Stream_">MQSeries::PubSub::Broker/Stream API enhanced to support alternate users</A>
	</UL>

	<LI><A HREF="#Changes_for_1_07">Changes for 1.07</A>
	<UL>

		<LI><A HREF="#MQSeries_Message_PCF_memory_le">MQSeries::Message::PCF memory leak</A>
		<LI><A HREF="#Change_to_simplify_static_compil">Change to simplify static compiles</A>
		<LI><A HREF="#Default_Expiry_values_were_wrong">Default Expiry values were wrong</A>
	</UL>

	<LI><A HREF="#Changes_for_1_06">Changes for 1.06</A>
	<UL>

		<LI><A HREF="#MQSeries_PubSub_">MQSeries::PubSub::*</A>
		<LI><A HREF="#MQSeries_Message_PCF">MQSeries::Message::PCF</A>
		<LI><A HREF="#MQSeries_Message_RulesFormat">MQSeries::Message::RulesFormat</A>
		<LI><A HREF="#MQSeries_Message_XML_Dumper">MQSeries::Message::XML-Dumper</A>
		<LI><A HREF="#MQSeries_Command">MQSeries::Command</A>
		<LI><A HREF="#MQSeries_QueueManager">MQSeries::QueueManager </A>
		<LI><A HREF="#MQSeries_Queue">MQSeries::Queue</A>
		<LI><A HREF="#MQSeries_core_module">MQSeries core module</A>
		<LI><A HREF="#Installation_Procedures_and_oth">Installation Procedures, and other Miscellany</A>
	</UL>

	<LI><A HREF="#Changes_for_1_05">Changes for 1.05</A>
	<UL>

		<LI><A HREF="#Installation_Procedures">Installation Procedures</A>
		<LI><A HREF="#MQSeries">MQSeries</A>
		<LI><A HREF="#MQSeries_QueueManager">MQSeries::QueueManager</A>
		<LI><A HREF="#MQSeries_Queue">MQSeries::Queue</A>
		<LI><A HREF="#MQSeries_Command">MQSeries::Command</A>
	</UL>

	<LI><A HREF="#Changes_for_1_04">Changes for 1.04</A>
	<UL>

		<LI><A HREF="#MQSeries">MQSeries</A>
		<LI><A HREF="#MQSeries_Command">MQSeries::Command</A>
		<LI><A HREF="#MQSeries_Message_Storable">MQSeries::Message::Storable</A>
	</UL>

	<LI><A HREF="#Changes_for_1_03">Changes for 1.03</A>
	<LI><A HREF="#Changes_for_1_02">Changes for 1.02</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="Introduction">Introduction

</A></H1>
This file documents the changes to each and every release of the MQSeries
perl API, going back as far as the 1.02 release.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_12">Changes for 1.12

</A></H1>
<P>
<HR>
<H2><A NAME="MQSeries_Command_Responses">MQSeries::Command->Responses

</A></H2>
The ``Response'' method of the MQSeries::Command class conflicts with the
MQSeries::Command::Response class, and this causes headaches in some code.
The method has been renamed to ``Responses''.


<P>

Now, this is obviously a non-backwards compatible change, however, that
method is very, very rarely used, and this will probably affect no existing
code. But, you've been warned.


<P>

<P>
<HR>
<H2><A NAME="Support_for_control_of_implicitl">Support for control of implicitly commited transactions

</A></H2>
WARNING: This is a very subtle, but very significant change to the API.
Anyone using transactions should read and understand the implications for
their application.


<P>

Normally, when there are pending tranactions due to uncommited
<CODE>MQPUT()</CODE> and/or <CODE>MQGET()</CODE> calls, they will be
implicitly backed out if the application crashes. This is a good thing. If
the application chooses to cleanly exit, and calls <CODE>MQDISC()</CODE>
without first calling <CODE>MQCMIT(),</CODE> then the transactions will be
implicitly commited. This is a good thing, when you do it intentionally.


<P>

In the MQSeries::QueueManager object destructor, the code does an
<CODE>MQDISC()</CODE> automatically in order to attempt to be a good
citizen and cleanly disconnect from queue manager automatically. However,
if an application has pending tranactions, and it traps a non-MQSeries
related error and dies, object destruction still occurs, and this means
that the pending transactions will be automatically commited, often to the
surprise of the application developer.


<P>

This release offers the developer control of this behavior, via the new
AutoCommit argument to the MQSeries::QueueManager constructor. If
AutoCommit is disabled, then the object destructor will call
<CODE>MQBACK()</CODE> before it calls <CODE>MQDISC(),</CODE> if there are
pending transactions (the rest of the code conspires to keep track of this
state information for you automatically, of course).


<P>

ANOTHER WARNING: The default behavior is not being changed in 1.12.
AutoCommit will be 1 by default, and transactions will be automatically
commited, in order to be backwards compatible with the current behavior. In
1.13, we will change this, since we feel very strongly that the intuitive
behavior should be the default. If the application does not explicitly
commit transactions, then they will be backed out when we destroy the
MQSeries::QueueManager objects.  


<P>

This means that applications will <STRONG>NOT</STRONG> be required to explicitly call <CODE>MQBACK()</CODE> (well, the
-&gt;Backout() method, that is) in all of their error handling. This is
especially important if you call some other API which itself raises fatal
exceptions, since you won't be required to trap them and take special
action. As of 1.13, we will Do The Right Thing.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_QueueManager_Connect_">MQSeries::QueueManager->Connect() timeout logic

</A></H2>
Attempts to connect to unhealthy queue managers can often hang
indefinetely, and there is no way for applications to interrupt the
connection, or trap the error. You simply hang until the queue manager (or
the wedged component) is killed.


<P>

The new MQSeries::QueueManager support a ConnectTimeout attributes which
puts a time limit on the <CODE>MQCONN()</CODE> call.


<P>

<P>
<HR>
<H2><A NAME="OS_390_Support">OS/390 Support

</A></H2>
The modules now compile and install on OS/390. See the README file for
version details.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Config_Authority">MQSeries::Config::Authority

</A></H2>
A new class under MQSeries::Config, which can be used to parse and query
authority files under Unix. The 'saveauth' program in the 'examples'
directory shows how this can be used to save all object authorities in a
file of 'setmqaut' commands.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject fix: Change, not Create

</A></H2>
Actually, this fixes a pretty serious bug. CreateObject, which is a
wonderfully powerful command, was also rather dangerous, because the author
(er, uh, that would be me -- wpm) got a bit pazy, and just used the PCF
Create commands, with the Replace option. That works fine if you are always
specifying all or most of the attributes you care about. If, however, you
provide a subset of the attributes you care about, the others will get
wiped out, since you are giving a sparse set of attributes to, say,
CreateQueue.


<P>

The code will now DTRT and use the Change commands if the object already
exists, and Create if it doesn't. This is far safer, and makes the code
very robust.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject fix: Comparing lists

</A></H2>
If one of the attributes passed in is a single element ARRAY reference, it
would not compare correctly with a real object attribute of only one
element, since the inquiry API will not return it as an ARRAY reference
unless there are two or more entries. A single element ARRAY ref will be
flattened to a scalar to make this comparison correct.


<P>

<P>
<HR>
<H2><A NAME="Limit_the_max_of_open_files_fo">Limit the max # of open files for MQSeries::FDC::Tail

</A></H2>
Some vendors impose a limit of 255 stdio files that can be open at the same
time (though the number of open file descriptors can be quite a bit
higher). For an queue manager running really poorly, the number of FDC
files being written may be higher than that, causing perl to die with a
``too many open files'' error. The MQSeries::FDC::Tail class will now close
and re-open files in such circumstances (using a least-recently-used
approach).


<P>

<P>
<HR>
<H2><A NAME="Support_for_symbolic_Wait_and_Ex">Support for symbolic Wait and Expiry values

</A></H2>
The 'Wait' and 'Expiry' parameters for MQSeries::Command, MQSeries::Queue
and MQSeries::PubSub::Command are specified in units of 1/1000 and 1/10 of
a second, making it easy to get the magnitude wrong. These parameters can
now also be specified as symbolic values, e.g. '45s' for 45 seconds and
'2m' for 2 minutes.


<P>

NOTE: These symbolic values work at the API top-level, but not when you
manually create a MsgDesc hash. Low-level values must be specified in
numeric form.


<P>

<P>
<HR>
<H2><A NAME="Use_of_GetConvert_error_checke">Use of GetConvert() error checked properly

</A></H2>
See the 1.11 changes notes about PutConvert, roughly a page or so below
this. It was an oversight not to make the analagous changes for GetConvert
as well as PutConvert.


<P>

<P>
<HR>
<H2><A NAME="GetConvertReason_and_PutConver">GetConvertReason() and PutConvertReason() methods added

</A></H2>
It is now possible to determine if the failure of a <CODE>Put(),</CODE>
<CODE>Put1()</CODE> or <CODE>Get()</CODE> method calls was a result of a
failed <CODE>PutConvert()</CODE> or <CODE>GetConvert()</CODE> method, which
is called internally by each of the first 3 methods.  


<P>

This is important when you want to know if the error was a result of an
improperly formatted message body, or an MQSeries problem.


<P>

While some noise gets generated via carp, there was until now no way to
determine this programmatically.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command_Support_for_o">MQSeries::Command: Support for ordered attributes

</A></H2>
The DeleteQueue command has an undocumented dependency on the order of its
optional attributes. We enhanced the configuration of the PCF attributes
such that we can now specify the order for these parameters. Without this
change, commands that specified the Purge option worked half the time,
since it was just lucky if perl pulled the hash entries out in the right
order.


<P>

Now, we force the parameters to be converted into PCF code in the correct
order. Currently, this only applies to the Optional parameters for
DeleteQueue, but if we run into any further undocumented order
dependencies, we can accomodate them easily.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_11">Changes for 1.11

</A></H1>
<P>
<HR>
<H2><A NAME="MQSeries_Config_classes">MQSeries::Config::* classes

</A></H2>
Two new classes under MQSeries::Config, specifically Machine and QMgr,
allow read access to the parsed /var/mqm/mqs.ini and
/var/mqm/qmgrs/*/qm.ini files.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_ErrorLog_classes">MQSeries::ErrorLog::* classes

</A></H2>
Three new classes under MQSeries::ErrorLog, specifically Tail, Parser, and
Entry, allow parsing and monitoring of errorlog files
(/var/mqm/errors/AMQERR0x.LOG, /var/mqm/qmgrs/*/errors/AMQERR0x.LOG).


<P>

<P>
<HR>
<H2><A NAME="MQSeries_FDC_classes">MQSeries::FDC::* classes

</A></H2>
Three new classes under MQSeries::FDC, specifically Tail, Parser, and
Entry, allow parsing and monitoring of FDC files (/var/mqm/errors/*.FDC).


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_DeadLetter_ob">MQSeries::Message::DeadLetter object

</A></H2>
A new subclass of MQSeries::Message, which implements parsing of the MQDLH,
has been added to the distribution. This makes it trivial to write dead
letter queue handler applications in perl.


<P>

<P>
<HR>
<H2><A NAME="Use_of_PutConvert_error_checke">Use of PutConvert() error checked properly

</A></H2>
We only error check the return value of the <CODE>PutConvert()</CODE>
method is one was actually called. This makes it possible to put empty
messages (where all of the information you care about is in the header, for
example).


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject method handles lists correctly

</A></H2>
This method tries very hard not to alter objects whose attributes are
already correctly set, but the previous version couldn't handle comparing
attributes whose values were lists. For example, if you give more than one
exit to the MsgExit parameter of a channel, then the PCF query will return
a list of values, and this is represented as an ARRAY reference.


<P>

The new version will correctly compare the array elements, and thus
correctly determine whether or not the attributes with multiple values are
in fact correct. And yes, order is of course important.


<P>

<P>
<HR>
<H2><A NAME="All_GetConvert_methods_save_ra">All GetConvert() methods save raw Buffer

</A></H2>
In all of the following modules, the <CODE>GetConvert()</CODE> method will
save the raw buffer, which in gives the developer access to the raw,
unconverted data, via the MQSeries::Message-&gt;Buffer() method.  


<P>

<PRE>  MQSeries::Message::Storable
  MQSeries::Message::XML-Dumper
  MQSeries::Message::RulesFormat
  MQSeries::Message::DeadLetter (new in 1.11 -- see above)
  MQSeries::Message::PCF
</PRE>

<P>

<PRE>  MQSeries::Command::Response
  MQSeries::PubSub::AdminMessage
</PRE>

<P>

A similar change was made to MQSeries::Message::Event, in the 1.09 release,
but this has not been done for all of the supported modules in the
distribution, for consistency (and, because the author happened to need
this for MQSeries::Message::Storable).


<P>

<P>
<HR>
<H2><A NAME="MQSeries_PubSub_ModelQName_">MQSeries::PubSub::*, ModelQName DynamicQName configurable

</A></H2>
Previously, the name of the permanent dynamic model queue, and dynamic
queue name to be created, were simply hardcoded in the object constructor
for both of


<P>

<PRE>  MQSeries::PubSub::Broker
  MQSeries::PubSub::Stream
</PRE>

<P>

Both are now configurable via arguments to the constructor.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_PubSub_AdminMessage_">MQSeries::PubSub::AdminMessage->_TranslatePCF

</A></H2>
This one is hard to explain. The code to parse the PCF admin messages for
PubSub wasn't handling multiple subscriber identities correctly. It does
now.  


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Queue_Open_was_sile">MQSeries::Queue->Open() was silent on non-retried errors

</A></H2>
There was a missing else condition to carp about an MQOPEN failure, if the
ReasonCode was <STRONG>not</STRONG> in the list of values to be retried. This causes significant confusion,
since the failure is silent.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_10">Changes for 1.10

</A></H1>
<P>
<HR>
<H2><A NAME="MQSeries_Command_MQSC_bugs">MQSeries::Command MQSC bugs

</A></H2>
Thanks to yet another data length limitation, the string ``INITIALIZING''
is too long for OS/390 to display, so this gets truncated to
``INITIALIZI'', for output of the <CODE>InquireChannelStatus()</CODE>
command, only on that platform. The API can parse this correctly now.


<P>

The IndexType values weren't properly mapped on either requests or
responses. Now they are.


<P>

The HardenGetBackout paremeter was incorrectly encoded in MQSC. It is now.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_allows_BufferL">MQSeries::Message allows BufferLength of 0

</A></H2>
This is one that came back to haunt me, as I thought I had fixed this way
back in 1.04. If you attempt to create an MQSeries::Message with a
BufferLength of zero, you actually get one with the default value of 32K.
This is bad, if you are writing some code to say, browse a queue and just
get all of the headers, as you end up getting some of the data, too. The
code does the right thing now, and properly accepts a BufferLength of 0.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject enhancements and documentation

</A></H2>
I added a new key (Clear) to indicate that when replacing a Local queue
with another QType, the Local queue should be cleared before being deleted.


<P>

There are also a couple of examples in the SYNOPSIS section, and
documentation for the new method call. This can now be considered
production, and is no longer experimental. The author uses this call almost
exclusively, in new development, for creating objects.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_09">Changes for 1.09

</A></H1>
<P>
<HR>
<H2><A NAME="Support_for_Win32">Support for Win32

</A></H2>
This release compiles on Windows NT 4.0, and has thus far been tested with
ActiveState 5.00503, build 521, with Visual C++ 6.0. Other perl/compiler
combinations will probably follow, but the initial support is all the
author has to test. I've tested it with 5.0 as a client, and 5.1 as both
client and server.


<P>

NOTE: (and a WARNING, too). This code determines where your MQSeries
installation is by querying the Windows Registry, using Win32::TieRegistry.
This is done not only at compile time (to find the includes files and
shared libs), but also at run time to determine whether or not to use the
client or server API, automatically.


<P>

<P>
<HR>
<H2><A NAME="Retry_logic_in_MQSeries_QueueMa">Retry logic in MQSeries::QueueManager->Connect() and MQSeries::Queue->Open()

</A></H2>
The retry logic was always there in MQSeries::QueueManager-&gt;Connect(),
but now it is much more configurable. You can specify which reasons codes
are worth retrying, rather than depend on a hardcoded (and possibly wrong
or incorrect) list.


<P>

MQSeries::Queue-&gt;Open() also support retry logic, and the author finds
this very useful for daemons recovering from a previous crash, attempting
to open a queue for exclusive input, and waiting for the previously invoked
agent process to free up the input handle.


<P>

The documentation for both modules has a RETRY LOGIC section. See that for
more information, as well as the documentation for the constructors, and
each of the specific methods.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command_new_takes_add">MQSeries::Command->new takes additional arguments.

</A></H2>
The MQSeries::Command constructor takes additional arguments allowing you
to specify the Model Queue, and DynamicQName used to open the dynamic reply
queue for command messages.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command_CreateObject_">MQSeries::Command->CreateObject() method added

</A></H2>
WARNING: This new method, while being Very Cool, is EXPERIMENTAL, and
intentionally not documented, as the API will likely change. It will
probably stabilize in 1.10.


<P>

CreateObject is a higher level wrapper function that will only create the
specified object if it doesn't exist, or the specified attributes don't
match. This is a conditional object creation, that will be a noop if the
object is already correctly configured.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_QueueManager_Hconn_ref">MQSeries::QueueManager Hconn reference counting

</A></H2>
A global hash, keyed on the process ID, and the Hconn value, will keep
track of how many MQSeries::QueueManager objects have been instantiated for
a given queue manager connections (since the Hconn values get reused). The
object destructor will now decrement these values, and only the last object
will actually disconnect from the queue manager.


<P>

This is actually a significant enhancement, as it was possible to
pre-maturely disconnect from the queue manager when instantiating lots of
objects, all of them specifying the queue manager by name, and thus
internally recreating lots of MQSeries::QueueManager objects. The first one
to get destroyed would wipe out the connection, causing problems for the
others.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_QueueManager_construct">MQSeries::QueueManager constructor arguments

</A></H2>
The constructor argument QueueManager can now be another
MQSeries::QueueManager argument, and the QueueManager name will be stolne
from that object, and a new one instantiated. This really just allows an
MQSeries::QueueManager object to be passed to the MQSeries::PubSub::Broker
constructor, actually.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Queue_Open_ignores_">MQSeries::Queue->Open() ignores the Hobj on errors

</A></H2>
The Hobj value returned by <CODE>MQOPEN()</CODE> is only saved in the
object hash when the CompCode is either MQCC_OK or MQCC_WARNING. The value
when there is a failure can be a large, useless negative number, but then
this looks like a true value in perl.


<P>

This confuses the subsequent attempts to call -&gt;Open(), which are
supposed to return true if the object is already opened. This was done via:


<P>

<PRE>        return 1 is $self-&gt;{Hobj};
</PRE>

<P>

which will be wrong. This is primarily relevant is you implement any form
of retry logic for failed queue opens.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_Buffer_meth">MQSeries::Message->Buffer() method added

</A></H2>
A new method to return the raw buffer from an <CODE>MQGET()</CODE> call.
This is relevant for classes which use <CODE>GetConvert()</CODE> methods to
translate the raw data into a customized form. If they save the raw buffer
into $self-&gt;{Buffer}, then it will be available.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_Event_GetCon">MQSeries::Message::Event->GetConvert() saves raw Buffer

</A></H2>
This <CODE>GetConvert()</CODE> method will save the raw buffer, which in
this case gives the developer access to the raw PCF data. The author uses
this to echo the original event, in its unaltered format, to other systems
management packages, afte rhe gets to it first.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_08">Changes for 1.08

</A></H1>
This is another relatively minor bug fix release, but since I'm releasing
it internally at MSDW, I'm also releasing it to CPAN as well.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_Event_was_bro">MQSeries::Message::Event was broken

</A></H2>
I made a global variable lexically scoped to its file with an erroneous
``my'' keyword. Don't do that. The Event parsing class was totally broken
as a result.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command_error_checking">MQSeries::Command error checking enhancement

</A></H2>
When a command fails, the <CODE>Reason()</CODE> was being set to the last
reason code found in the returned messages, which is always 3008 (command
failed). Now the code will catch the first non-zero return code, and
default to that, and this reason code is usually the one you want.  


<P>

For example, InquireQueue for a non-existent queue name will now return
2085 (object not found), instead of the generic and uninteresting 3008.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_QueueManager_and_MQSer">MQSeries::QueueManager and MQSeries::Queue constructor bug

</A></H2>
Although I don't recommend using this particular interface, the
constructors for both of these classes allow you to pass scalar references
for the Reason and CompCode, so that the <CODE>MQCONN()</CODE> or
<CODE>MQOPEN()</CODE> errors, if any, can be obtained.  


<P>

These were only being set if there was an error, and now they are set
regardless. Thus, if you initialize the values to, say
MQRC_UNEXPECTED_ERROR and MQCC_FAILED, they will be left that way.


<P>

Note that I highly recommend using the NoAutoConnect and NoAutoOpen
arguments, and then error checking the -&gt;Connect() and -&gt;Open()
methods explicitly. The resulting code is much cleaner, IM!HO.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Queue_Put_method_wa">MQSeries::Queue->Put() method wasn't setting MQPMO_FAIL_IF_QUIESCING

</A></H2>
The various <CODE>*_FAIL_IF_QUIESCING</CODE> options are set everywhere by
default (as the author happens to beleive they should be), except here.
This is fixed.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_PubSub_Broker_Stream_">MQSeries::PubSub::Broker/Stream API enhanced to support alternate users

</A></H2>
In order to enable the development of adminstrative tools for
Publish/Subscribe which allow me to age bogus subscriptions (i.e.
subscriptions that point to non-existent queues), I needed to be able to
DeregisterSubscriber as an alternate user ID.


<P>

The API was enhanced to expose a bit more of the underlying method calls in
order to make this possible.  


<P>

In addition, several minor bugs in the Administrative PubSub API were
fixed, making it possible to get at almost all of the metatopic information
easily.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_07">Changes for 1.07

</A></H1>
This release is a minor bug fix release, but one of them is significant
enough to justify a public release.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_PCF_memory_le">MQSeries::Message::PCF memory leak

</A></H2>
The MQDecodePCF routine didn't properly mortalize the references it
returns. I hate it when that happens. The result was that long-running
applications that used the Command API (or any of the PCF-based formats)
heavily (guess what the author was developing when he discovered this? ;-)
will leak memory heavily. This is fixed.


<P>

In addition, the same error was made in the MQSeries::Message::RulesFormat
XS code as well, and that was also fixed.  


<P>

Note that none of the basic MQI interfaces had any problems at all. There
are now no known memory leaks anywhere in the XS code. We've had long
running perl daemons up for weeks using the basic MQSeries interface, with
no reported issues.


<P>

<P>
<HR>
<H2><A NAME="Change_to_simplify_static_compil">Change to simplify static compiles

</A></H2>
The obnoxious, er, I mean, very important and absolutely essential legal
question about the LICENSE file will be asked only once. When compiling
statically, the Makefile.PL gets run again, and if it blocks on input this
is not only annoying, but it breaks the static compile.


<P>

<P>
<HR>
<H2><A NAME="Default_Expiry_values_were_wrong">Default Expiry values were wrong

</A></H2>
The default Expiry values used in the MQSeries::Command API were incorrect,
having the same value as the WaitInterval. As you probably know, Expiry is
tenths of a second, and Wait is milliseconds. Oops.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_06">Changes for 1.06

</A></H1>
This release is the first to make it to CPAN (the Comprehensive Perl
Archive Network), as the primary distribution mechanism, rather than IBM's
proprietary Support Pac web site. In addition, this code is now copyrighted
by MSDW (the author's employer) but released under a license which is based
on the Perl Artistic License.


<P>

It is now truly Open Source. Viva the Revolution, baby...


<P>

<P>
<HR>
<H2><A NAME="MQSeries_PubSub_">MQSeries::PubSub::*

</A></H2>
The entire Publish/Subscribe API is new with this release. This includes
the following modules:


<P>

<DL>
<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::Command

</A></STRONG><DD>
A base class for all of the Publish/Subscribe commands, this module is not
used directly, but rather one of its two subclasses is.


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::Broker

</A></STRONG><DD>
This subclass of MQSeries::PubSub::Command, and MQSeries::QueueManager,
implements an interface to the Broker-specific Publish/Subscribe commands.


<P>

This module also supports an set of ``Extended Commands'', which are higher
level interfaces to the contents of the administrative inforamtion in the
metatopics.


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::Stream

</A></STRONG><DD>
This subclass of MQSeries::PubSub::Command, and MQSeries::Queue, implements
an interface to the Stream-specific Publish/Subscribe commands.


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::Message

</A></STRONG><DD>
This subclass of MQSeries::Message::RulesFormat provides an interface for
creating and parsing MQRFH-formated Publish/Subscribe messages.


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::AdminMessage

</A></STRONG><DD>
This quasi-subclass (not a *true* OO subclass, but who's looking) of
MQSeries::Message::PCF provides an interface to the Publish/Subscribe
administrative messages published in PCF format.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_Message_PCF">MQSeries::Message::PCF

</A></H2>
This is a new class which provides a much more generic interface to PCF
messages. Prior to this release, there were several routines which parsed
implementation-specific formats, with a lot of duplicated code.


<P>

This class can be used directly, but it was primary designed so that its
two core functions (MQEncodePCF and MQDecodePCF) would be used as building
blocks for the implementation-specific formats, such as Performance Events
(MQSeries::Message::Event), Command server requests and responses
(MQSeries::Command::*), and the Publish/Subscribe administrative messages
(MQSeries::PubSub::AdminMessage).


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_RulesFormat">MQSeries::Message::RulesFormat

</A></H2>
This is a new class which provides an interface to the MQRFH Rules and
Format messages used by the Publish/Subscribe system. This can also be used
to create messages for working with the NEON MQIntegrator 1.X product
suites, since the format is the same, although the author hasn't actually
tried this yet.  


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_XML_Dumper">MQSeries::Message::XML-Dumper

</A></H2>
This is a new subclass of MQSeries::Message which encodes/decodes complex
perl data structures using the XML-Dumper module. This was mostly done as a
proof of principle, and to please some XML zealots.


<P>

Note that the parsing of XML is much more expensive than the Storable
approach, and if you have a perl process on the sending and receiving end
of a message flow, the author still recommends using Storable.


<P>

This requires the CPAN XML::Dumper and XML::Parser modules.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command">MQSeries::Command

</A></H2>
<DL>
<DT><STRONG><A NAME="item_More">More complete documentation

</A></STRONG><DD>
The various strings used to represent the PCF parameters and values have
finally been documented, so someone other than the author may actually be
able to use this code.


<P>

<DT><STRONG><A NAME="item_Extended">Extended to V5.1 PCF Commands

</A></STRONG><DD>
All of the new Commands for V5.1 are supported, and in fact, even if you
compile the MQSeries API with 5.0, you can still use the new commands, and
parse the resulting PCF parameters. The code which maps numeric parameters
to key strings has been ``flattened'' such that it doesn't use the actual C
macros.


<P>

These files (MQSeries/Command/PCF/*.pl) were auto-generated on an MQSeries
5.1 host, so the macro-to-number mapping has already been done, and it is
not necessary for the C macro to have been compiled into constants.c.


<P>

<DT><STRONG>Extended to V2.1 MQSC Commands

</A></STRONG><DD>
Most, but not all, of the MQSC commands (i.e. commands sent to an MQSC-only
command server, for example an MVS queue manager) have been supported, and
the API can parse all of new V2.1 object attributes (like ``ALTDATE'' and
``ALTTIME'').


<P>

WARNING: The MQSC code has not been extensively tested, so use it with
caution.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_QueueManager">MQSeries::QueueManager 

</A></H2>
<DL>
<DT><STRONG><A NAME="item_NoAutoConnect">NoAutoConnect option

</A></STRONG><DD>
The call to MQCONN is normally done in the constructor, but if it fails,
the error checking semantics are ugly. A new option (NoAutoConnect)
disables the implicit call to -&gt;Connect(), and allows the developer to
make this call, and error check it explicitly.


<P>

The <CODE>Connect()</CODE> method is also new.


<P>

<DT><STRONG><A NAME="item_Inquire">Inquire/MQINQ Support

</A></STRONG><DD>
Method calls have added to support the <CODE>MQINQ()</CODE> call against
the queue manager itself. This includes both <CODE>Open()</CODE> and
<CODE>Close()</CODE> methods, which were not previously available.


<P>

The <CODE>Open()</CODE> method is also new, although it is just a rename of
the older semi-private <CODE>_mqopen()</CODE> method call.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_Queue">MQSeries::Queue

</A></H2>
<DL>
<DT><STRONG><A NAME="item_NoAutoOpen">NoAutoOpen option

</A></STRONG><DD>
The call to MQOPEN is normally done in the constructor, but if it fails,
the error checking semantics are ugly. A new option (NoAutoOpen) disables
the implicit call to -&gt;Open(), and allows the developer to make this
call, and error check it explicitly.


<P>

<DT><STRONG><A NAME="item_Inquire">Inquire/Set MQINQ/MQSET Support

</A></STRONG><DD>
Method calls have added to support the <CODE>MQINQ()</CODE> and
<CODE>MQSET()</CODE> calls against queues.  


<P>

<DT><STRONG><A NAME="item_Close">Close method call

</A></STRONG><DD>
Objects can now be explicitly closed. In previous releases this was done
via the object destructor, and thus couldn't be error checked. Implicit
closing is still preferred, but CloseOptions can be given to the
constructor to control how the object is closed.


<P>

This is particularly useful for creating permanent dynamic queues (which
can accept persistent messages) which are purged and deleted upon close.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_core_module">MQSeries core module

</A></H2>
<DL>
<DT><STRONG><A NAME="item_Null">Null-valued macros properly supported

</A></STRONG><DD>
There are several macros, such as MQCI_NONE, which are a fixed length
string of null characters. These were not properly defined in the
constants.c file, and thus couldn't be used as expected.


<P>

Now, these macros all evaluate to a string of nulls of the correct length,
this you can use them precisely as documented in the MQI docs.


<P>

<DT><STRONG><A NAME="item_MQParseEvent">MQParseEvent, MQCommandRequestPCF, MQCommandResponsePCF and MQParseDeadLetter

</A></STRONG><DD>
These core module subroutines were removed.


<P>

MQParseDeadLetter never worked, and it will be implemented (eventually) in
the same way that MQSeries::Message::RulesFormat was done, with its own XS
source file.


<P>

The other 3 all dealt with very specific implementations of the PCF format,
and these were replaced by the MQSeries::Message::PCF class, which provides
very generic PCF parsing and encoding routines (MQEncodePCF and
MQDecodePCF).


<P>

Mapping the generic PCF into message format specific data is done by
``private'' class methods _TranslatePCF in each of the relevant OO modules.


<P>

This was a key prerequisite for developing MQSeries::PubSub::AdminMessage,
which is also based on a PCF message format. Future implementations of
special formats based on PCF should be easy. Of course, now IBM wants to
move to XML for everything, so...


<P>

<DT><STRONG><A NAME="item_MQReasonToStrings">MQReasonToStrings

</A></STRONG><DD>
This subroutine's implementation was dramatically reworked.


<P>

This used to be implemented in C, inside the XS routine, but now the hash
of key/value pairs mapping a numeric ReasonCode to a readable test string
is done via a pair of automatically compiled files
(MQSeries/Constants/Reason*.pl)


<P>

In fact, all of the files in MQSeries/Constants are auto-generated from
templates in src/pre.in, by the tool src/util/flatten_macros. This is a
huge win, as it basically does the macro-to-value mapping such that the
perl API is dealing with raw numbers.  


<P>

There is a non-trivial startup cost otherwise, as each and every macro has
to be looked up in the symbol table, the AUTOLOAD function called, a C
subroutine called, etc. This saves a few seconds of startup time.


<P>

<DT><STRONG><A NAME="item_XS">XS code streamlined

</A></STRONG><DD>
Most of the non-MQI subroutines were removed entirely, or moved elsewhere.
The MQSeries.xs.in directory is much more lean.


<P>

<DT><STRONG>XS code no longer leaks memory

</A></STRONG><DD>
The author now fully understands the XS concepts of mortality and reference
counts, and the code returns correctly mortalized, and properly reference
counted values.  


<P>

<DT><STRONG><A NAME="item_Support">Support for "default" queue manager

</A></STRONG><DD>
The QueueManager key is no longer required by most of the OO API
constructors. If you have configured a default queue manager for your
environment, then you can use it with the OO API as of this release.
Before, the QueueManager key was required to have a true value, and since
the default queue manager is ``'', and ``'' is false...


<P>

</DL>
<P>
<HR>
<H2><A NAME="Installation_Procedures_and_oth">Installation Procedures, and other Miscellany

</A></H2>
<OL>
<LI><STRONG><A NAME="item_004_required_not_5_005">004 required, not 5.005

</A></STRONG>
The 5.005 prerequisite was relaxed to 5.004, and the requirement that the
perl interpreter itself be linked directly with -lthread (or -lpthread, or
whatever) was removed. The MQSeries.so libraries are themselves compiled
with the appropriate dependencies on libthread, and this code now works
fine with a standard, out-of-the-tarball compile of perl5.004 or later.


<P>

<DT><STRONG><A NAME="item_New">New CONFIG parameters

</A></STRONG><DD>
It is now possible to explicitly disable either the server or client API
compile. The Makefile.PL now does a more generic job of determining whether
or not you appear to have support for the server API, which is the more
common case (eg. Linux, SunOS and IRIX only have client implementations
available).


<P>

At least one site didn't support clients at all, and they didn't want to
build in the support, so they can now turn it off via CONFIG.


<P>

<DT><STRONG><A NAME="item_MANIFEST">MANIFEST and .exclude auto-generated

</A></STRONG><DD>
These files are now auto-generated by development utilities in the util
subdirectory, rather than being updated manually.


<P>

</OL>
<P>
<HR>
<H1><A NAME="Changes_for_1_05">Changes for 1.05

</A></H1>
This release required 5.005, built with thread support (this restriction
was subsequently removed in 1.06).


<P>

<P>
<HR>
<H2><A NAME="Installation_Procedures">Installation Procedures

</A></H2>
<DL>
<DT><STRONG><A NAME="item_MQServer">MQServer::MQSeries made optional

</A></STRONG><DD>
Compilation of the MQServer::MQSeries API is automatically disabled on
SunOS 4.1.3 and IRIX hosts, for which we do not have a server API.


<P>

<DT><STRONG><A NAME="item_constants">constants.c.PL added

</A></STRONG><DD>
The huge, growing list of MQSeries C macros are now extracted from the
MQSeries C include files automatically, and the <CODE>@EXPORT</CODE> list
is built dynamically. The code for constants.c is also auto-generated, and
the code handles several different types of constant (hex, string,
character, etc).


<P>

The code also parses all of the available C header files, and makes all
possible macros available. This makes maintenance of the macro list easy,
but it does result in significant bloat of the namespace exported by
MQSeries. So be it.


<P>

<DT><STRONG><A NAME="item_Test">Test suite

</A></STRONG><DD>
The test suite was reorganized to a SysV-style rc.d directory syntax, with
files named 10foo.t, 20bar.t, etc.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries">MQSeries

</A></H2>
<DL>
<DT><STRONG><A NAME="item_Distribution">Distribution List Support

</A></STRONG><DD>
Support for Distribution lists was added to the core MQI functions, such as
MQOPEN, MQPUT and MQPUT1. This required a significant re-architecture of
these functions. The OO API classes were also extended to support dist
lists as well.


<P>

This functionality is all enabled only if one compiles with V5, of course.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_QueueManager">MQSeries::QueueManager

</A></H2>
<DL>
<DT><STRONG><A NAME="item_MQCONN">MQCONN retry logic

</A></STRONG><DD>
The MQCONN retry logic is disabled by default.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_Queue">MQSeries::Queue

</A></H2>
<DL>
<DT><STRONG><A NAME="item_MQOPEN">MQOPEN retry logic

</A></STRONG><DD>
This was stripped out of the code entirely, since it never really worked,
and I doubt it ever would have. Bad idea.


<P>

<DT><STRONG><A NAME="item_AutoResize">AutoResize logic

</A></STRONG><DD>
Logic was added to adjust the buffer size automatically, and retry an
<CODE>MQGET()</CODE> call, when a truncated message is received, and
truncated messages are not accepted. This functionality is available in the
C++ API, the source of inspiration for the idea.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_Command">MQSeries::Command

</A></H2>
<DL>
<DT><STRONG><A NAME="item_Documentation">Documentation

</A></STRONG><DD>
This module was finally documented, but only the object constructor and
basic methods were documented. Complete documentation of the command syntax
was not added until 1.06.


<P>

</DL>
<P>
<HR>
<H1><A NAME="Changes_for_1_04">Changes for 1.04

</A></H1>
<P>
<HR>
<H2><A NAME="MQSeries">MQSeries

</A></H2>
Supports explicit loading of MQClient::MQSeries or MQServer::MQSeries,
rather than implicit only.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command">MQSeries::Command

</A></H2>
Introduce the Command Server API, for both PCF and MQSC command messages.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_Storable">MQSeries::Message::Storable

</A></H2>
Uses nfreeze, which is supposed to use network byte order, rather than
freeze.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_03">Changes for 1.03

</A></H1>
<DL>
<DT><STRONG><A NAME="item_OO">OO API

</A></STRONG><DD>
First implementation of the OO portion of the API


<P>

<DT><STRONG>XS source

</A></STRONG><DD>
Eliminated the dual XS file templates, using one source for both V2 and V5


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries core

</A></STRONG><DD>
Added two new utility functions to the core API:


<P>

<PRE>    MQParseEvent
    MQReasonToText
</PRE>

<P>

<DT><STRONG><A NAME="item_Locale">Locale hacks

</A></STRONG><DD>
MQSeries.pm will automagically set reasonable values for the LANG and
NLSPATH environment variables, if not set.


<P>

<DT><STRONG>Documentation

</A></STRONG><DD>
Significantly expanded documentation


<P>

</DL>
<P>
<HR>
<H1><A NAME="Changes_for_1_02">Changes for 1.02

</A></H1>
<DL>
<DT><STRONG><A NAME="item_Introduced">Introduced the extended test suite

</A></STRONG><DD>
<DT><STRONG><A NAME="item_Dual">Dual client/server support

</A></STRONG><DD>
Introduced the dual namespaces to make client vs. server usage transparent.
That is, MQSeries.pm really pulls in MQServer/MQSeries.pm on a queue
manager, and MQClient/MQSeries.pm otherwise.


<P>

<DT><STRONG><A NAME="item_PLMQ">PLMQ -> MQSeries

</A></STRONG><DD>
Change the module name from PLMQ to MQSeries, and changed the API calls
from GET to MQGET, etc., making the function mapping one to one.


<P>

<DT><STRONG><A NAME="item_typemap">typemap.PL

</A></STRONG><DD>
Automated the typemap generation using a typemap.PL file


<P>

</DL>
</DL>
    </BODY>

    </HTML>
