    <HTML> 
	<HEAD> 
	    <TITLE>Changes.src</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#Introduction">Introduction</A>
	<LI><A HREF="#Changes_for_1_06">Changes for 1.06</A>
	<UL>

		<LI><A HREF="#MQSeries_PubSub_">MQSeries::PubSub::*</A>
		<LI><A HREF="#MQSeries_Message_PCF">MQSeries::Message::PCF</A>
		<LI><A HREF="#MQSeries_Message_RulesFormat">MQSeries::Message::RulesFormat</A>
		<LI><A HREF="#MQSeries_Message_XML_Dumper">MQSeries::Message::XML-Dumper</A>
		<LI><A HREF="#MQSeries_Command">MQSeries::Command</A>
		<LI><A HREF="#MQSeries_QueueManager">MQSeries::QueueManager </A>
		<LI><A HREF="#MQSeries_Queue">MQSeries::Queue</A>
		<LI><A HREF="#MQSeries_core_module">MQSeries core module</A>
		<LI><A HREF="#Installation_Procedures_and_oth">Installation Procedures, and other Miscellany</A>
	</UL>

	<LI><A HREF="#Changes_for_1_05">Changes for 1.05</A>
	<UL>

		<LI><A HREF="#Installation_Procedures">Installation Procedures</A>
		<LI><A HREF="#MQSeries">MQSeries</A>
		<LI><A HREF="#MQSeries_QueueManager">MQSeries::QueueManager</A>
		<LI><A HREF="#MQSeries_Queue">MQSeries::Queue</A>
		<LI><A HREF="#MQSeries_Command">MQSeries::Command</A>
	</UL>

	<LI><A HREF="#Changes_for_1_04">Changes for 1.04</A>
	<UL>

		<LI><A HREF="#MQSeries">MQSeries</A>
		<LI><A HREF="#MQSeries_Command">MQSeries::Command</A>
		<LI><A HREF="#MQSeries_Message_Storable">MQSeries::Message::Storable</A>
	</UL>

	<LI><A HREF="#Changes_for_1_03">Changes for 1.03</A>
	<LI><A HREF="#Changes_for_1_02">Changes for 1.02</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="Introduction">Introduction

</A></H1>
This file documents the changes to each and every release of the MQSeries
perl API, going back as far as the 1.02 release.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_06">Changes for 1.06

</A></H1>
This release is the first to make it to CPAN (the Comprehensive Perl
Archive Network), as the primary distribution mechanism, rather than IBM's
proprietary Support Pac web site. In addition, this code is now copyrighted
by MSDW (the author's employer) but released under a license which is based
on the Perl Artistic License.


<P>

It is now truly Open Source. Viva the Revolution, baby...


<P>

<P>
<HR>
<H2><A NAME="MQSeries_PubSub_">MQSeries::PubSub::*

</A></H2>
The entire Publish/Subscribe API is new with this release. This includes
the following modules:


<P>

<DL>
<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::Command

</A></STRONG><DD>
A base class for all of the Publish/Subscribe commands, this module is not
used directly, but rather one of its two subclasses is.


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::Broker

</A></STRONG><DD>
This subclass of MQSeries::PubSub::Command, and MQSeries::QueueManager,
implements an interface to the Broker-specific Publish/Subscribe commands.


<P>

This module also supports an set of ``Extended Commands'', which are higher
level interfaces to the contents of the administrative inforamtion in the
metatopics.


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::Stream

</A></STRONG><DD>
This subclass of MQSeries::PubSub::Command, and MQSeries::Queue, implements
an interface to the Stream-specific Publish/Subscribe commands.


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::Message

</A></STRONG><DD>
This subclass of MQSeries::Message::RulesFormat provides an interface for
creating and parsing MQRFH-formated Publish/Subscribe messages.


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries::PubSub::AdminMessage

</A></STRONG><DD>
This quasi-subclass (not a *true* OO subclass, but who's looking) of
MQSeries::Message::PCF provides an interface to the Publish/Subscribe
administrative messages published in PCF format.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_Message_PCF">MQSeries::Message::PCF

</A></H2>
This is a new class which provides a much more generic interface to PCF
messages. Prior to this release, there were several routines which parsed
implementation-specific formats, with a lot of duplicated code.


<P>

This class can be used directly, but it was primary designed so that its
two core functions (MQEncodePCF and MQDecodePCF) would be used as building
blocks for the implementation-specific formats, such as Performance Events
(MQSeries::Message::Event), Command server requests and responses
(MQSeries::Command::*), and the Publish/Subscribe administrative messages
(MQSeries::PubSub::AdminMessage).


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_RulesFormat">MQSeries::Message::RulesFormat

</A></H2>
This is a new class which provides an interface to the MQRFH Rules and
Format messages used by the Publish/Subscribe system. This can also be used
to create messages for working with the NEON MQIntegrator 1.X product
suites, since the format is the same, although the author hasn't actually
tried this yet.  


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_XML_Dumper">MQSeries::Message::XML-Dumper

</A></H2>
This is a new subclass of MQSeries::Message which encodes/decodes complex
perl data structures using the XML-Dumper module. This was mostly done as a
proof of principle, and to please some XML zealots.


<P>

Note that the parsing of XML is much more expensive than the Storable
approach, and if you have a perl process on the sending and receiving end
of a message flow, the author still recommends using Storable.


<P>

This requires the CPAN XML::Dumper and XML::Parser modules.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command">MQSeries::Command

</A></H2>
<DL>
<DT><STRONG><A NAME="item_More">More complete documentation

</A></STRONG><DD>
The various strings used to represent the PCF parameters and values have
finally been documented, so someone other than the author may actually be
able to use this code.


<P>

<DT><STRONG><A NAME="item_Extended">Extended to V5.1 PCF Commands

</A></STRONG><DD>
All of the new Commands for V5.1 are supported, and in fact, even if you
compile the MQSeries API with 5.0, you can still use the new commands, and
parse the resulting PCF parameters. The code which maps numeric parameters
to key strings has been ``flattened'' such that it doesn't use the actual C
macros.


<P>

These files (MQSeries/Command/PCF/*.pl) were auto-generated on an MQSeries
5.1 host, so the macro-to-number mapping has already been done, and it is
not necessary for the C macro to have been compiled into constants.c.


<P>

<DT><STRONG>Extended to V2.1 MQSC Commands

</A></STRONG><DD>
Most, but not all, of the MQSC commands (i.e. commands sent to an MQSC-only
command server, for example an MVS queue manager) have been supported, and
the API can parse all of new V2.1 object attributes (like ``ALTDATE'' and
``ALTTIME'').


<P>

WARNING: The MQSC code has not been extensively tested, so use it with
caution.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_QueueManager">MQSeries::QueueManager 

</A></H2>
<DL>
<DT><STRONG><A NAME="item_NoAutoConnect">NoAutoConnect option

</A></STRONG><DD>
The call to MQCONN is normally done in the constructor, but if it fails,
the error checking semantics are ugly. A new option (NoAutoConnect)
disables the implicit call to -&gt;Connect(), and allows the developer to
make this call, and error check it explicitly.


<P>

The <CODE>Connect()</CODE> method is also new.


<P>

<DT><STRONG><A NAME="item_Inquire">Inquire/MQINQ Support

</A></STRONG><DD>
Method calls have added to support the <CODE>MQINQ()</CODE> call against
the queue manager itself. This includes both <CODE>Open()</CODE> and
<CODE>Close()</CODE> methods, which were not previously available.


<P>

The <CODE>Open()</CODE> method is also new, although it is just a rename of
the older semi-private <CODE>_mqopen()</CODE> method call.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_Queue">MQSeries::Queue

</A></H2>
<DL>
<DT><STRONG><A NAME="item_NoAutoOpen">NoAutoOpen option

</A></STRONG><DD>
The call to MQOPEN is normally done in the constructor, but if it fails,
the error checking semantics are ugly. A new option (NoAutoOpen) disables
the implicit call to -&gt;Open(), and allows the developer to make this
call, and error check it explicitly.


<P>

<DT><STRONG><A NAME="item_Inquire">Inquire/Set MQINQ/MQSET Support

</A></STRONG><DD>
Method calls have added to support the <CODE>MQINQ()</CODE> and
<CODE>MQSET()</CODE> calls against queues.  


<P>

<DT><STRONG><A NAME="item_Close">Close method call

</A></STRONG><DD>
Objects can now be explicitly closed. In previous releases this was done
via the object destructor, and thus couldn't be error checked. Implicit
closing is still preferred, but CloseOptions can be given to the
constructor to control how the object is closed.


<P>

This is particularly useful for creating permanent dynamic queues (which
can accept persistent messages) which are purged and deleted upon close.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_core_module">MQSeries core module

</A></H2>
<DL>
<DT><STRONG><A NAME="item_Null">Null-valued macros properly supported

</A></STRONG><DD>
There are several macros, such as MQCI_NONE, which are a fixed length
string of null characters. These were not properly defined in the
constants.c file, and thus couldn't be used as expected.


<P>

Now, these macros all evaluate to a string of nulls of the correct length,
this you can use them precisely as documented in the MQI docs.


<P>

<DT><STRONG><A NAME="item_MQParseEvent">MQParseEvent, MQCommandRequestPCF, MQCommandResponsePCF and MQParseDeadLetter

</A></STRONG><DD>
These core module subroutines were removed.


<P>

MQParseDeadLetter never worked, and it will be implemented (eventually) in
the same way that MQSeries::Message::RulesFormat was done, with its own XS
source file.


<P>

The other 3 all dealt with very specific implementations of the PCF format,
and these were replaced by the MQSeries::Message::PCF class, which provides
very generic PCF parsing and encoding routines (MQEncodePCF and
MQDecodePCF).


<P>

Mapping the generic PCF into message format specific data is done by
``private'' class methods _TranslatePCF in each of the relevant OO modules.


<P>

This was a key prerequisite for developing MQSeries::PubSub::AdminMessage,
which is also based on a PCF message format. Future implementations of
special formats based on PCF should be easy. Of course, now IBM wants to
move to XML for everything, so...


<P>

<DT><STRONG><A NAME="item_MQReasonToStrings">MQReasonToStrings

</A></STRONG><DD>
This subroutine's implementation was dramatically reworked.


<P>

This used to be implemented in C, inside the XS routine, but now the hash
of key/value pairs mapping a numeric ReasonCode to a readable test string
is done via a pair of automatically compiled files
(MQSeries/Constants/Reason*.pl)


<P>

In fact, all of the files in MQSeries/Constants are auto-generated from
templates in src/pre.in, by the tool src/util/flatten_macros. This is a
huge win, as it basically does the macro-to-value mapping such that the
perl API is dealing with raw numbers.  


<P>

There is a non-trivial startup cost otherwise, as each and every macro has
to be looked up in the symbol table, the AUTOLOAD function called, a C
subroutine called, etc. This saves a few seconds of startup time.


<P>

<DT><STRONG><A NAME="item_XS">XS code streamlined

</A></STRONG><DD>
Most of the non-MQI subroutines were removed entirely, or moved elsewhere.
The MQSeries.xs.in directory is much more lean.


<P>

<DT><STRONG>XS code no longer leaks memory

</A></STRONG><DD>
The author now fully understands the XS concepts of mortality and reference
counts, and the code returns correctly mortalized, and properly reference
counted values.  


<P>

<DT><STRONG><A NAME="item_Support">Support for "default" queue manager

</A></STRONG><DD>
The QueueManager key is no longer required by most of the OO API
constructors. If you have configured a default queue manager for your
environment, then you can use it with the OO API as of this release.
Before, the QueueManager key was required to have a true value, and since
the default queue manager is ``'', and ``'' is false...


<P>

</DL>
<P>
<HR>
<H2><A NAME="Installation_Procedures_and_oth">Installation Procedures, and other Miscellany

</A></H2>
<OL>
<LI><STRONG><A NAME="item_004_required_not_5_005">004 required, not 5.005

</A></STRONG>
The 5.005 prerequisite was relaxed to 5.004, and the requirement that the
perl interpreter itself be linked directly with -lthread (or -lpthread, or
whatever) was removed. The MQSeries.so libraries are themselves compiled
with the appropriate dependencies on libthread, and this code now works
fine with a standard, out-of-the-tarball compile of perl5.004 or later.


<P>

<DT><STRONG><A NAME="item_New">New CONFIG parameters

</A></STRONG><DD>
It is now possible to explicitly disable either the server or client API
compile. The Makefile.PL now does a more generic job of determining whether
or not you appear to have support for the server API, which is the more
common case (eg. Linux, SunOS and IRIX only have client implementations
available).


<P>

At least one site didn't support clients at all, and they didn't want to
build in the support, so they can now turn it off via CONFIG.


<P>

<DT><STRONG><A NAME="item_MANIFEST">MANIFEST and .exclude auto-generated

</A></STRONG><DD>
These files are now auto-generated by development utilities in the util
subdirectory, rather than being updated manually.


<P>

</OL>
<P>
<HR>
<H1><A NAME="Changes_for_1_05">Changes for 1.05

</A></H1>
This release required 5.005, built with thread support (this restriction
was subsequently removed in 1.06).


<P>

<P>
<HR>
<H2><A NAME="Installation_Procedures">Installation Procedures

</A></H2>
<DL>
<DT><STRONG><A NAME="item_MQServer">MQServer::MQSeries made optional

</A></STRONG><DD>
Compilation of the MQServer::MQSeries API is automatically disabled on
SunOS 4.1.3 and IRIX hosts, for which we do not have a server API.


<P>

<DT><STRONG><A NAME="item_constants">constants.c.PL added

</A></STRONG><DD>
The huge, growing list of MQSeries C macros are now extracted from the
MQSeries C include files automatically, and the <CODE>@EXPORT</CODE> list
is built dynamically. The code for constants.c is also auto-generated, and
the code handles several different types of constant (hex, string,
character, etc).


<P>

The code also parses all of the available C header files, and makes all
possible macros available. This makes maintenance of the macro list easy,
but it does result in significant bloat of the namespace exported by
MQSeries. So be it.


<P>

<DT><STRONG><A NAME="item_Test">Test suite

</A></STRONG><DD>
The test suite was reorganized to a SysV-style rc.d directory syntax, with
files named 10foo.t, 20bar.t, etc.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries">MQSeries

</A></H2>
<DL>
<DT><STRONG><A NAME="item_Distribution">Distribution List Support

</A></STRONG><DD>
Support for Distribution lists was added to the core MQI functions, such as
MQOPEN, MQPUT and MQPUT1. This required a significant re-architecture of
these functions. The OO API classes were also extended to support dist
lists as well.


<P>

This functionality is all enabled only if one compiles with V5, of course.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_QueueManager">MQSeries::QueueManager

</A></H2>
<DL>
<DT><STRONG><A NAME="item_MQCONN">MQCONN retry logic

</A></STRONG><DD>
The MQCONN retry logic is disabled by default.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_Queue">MQSeries::Queue

</A></H2>
<DL>
<DT><STRONG><A NAME="item_MQOPEN">MQOPEN retry logic

</A></STRONG><DD>
This was stripped out of the code entirely, since it never really worked,
and I doubt it ever would have. Bad idea.


<P>

<DT><STRONG><A NAME="item_AutoResize">AutoResize logic

</A></STRONG><DD>
Logic was added to adjust the buffer size automatically, and retry an
<CODE>MQGET()</CODE> call, when a truncated message is received, and
truncated messages are not accepted. This functionality is available in the
C++ API, the source of inspiration for the idea.


<P>

</DL>
<P>
<HR>
<H2><A NAME="MQSeries_Command">MQSeries::Command

</A></H2>
<DL>
<DT><STRONG><A NAME="item_Documentation">Documentation

</A></STRONG><DD>
This module was finally documented, but only the object constructor and
basic methods were documented. Complete documentation of the command syntax
was not added until 1.06.


<P>

</DL>
<P>
<HR>
<H1><A NAME="Changes_for_1_04">Changes for 1.04

</A></H1>
<P>
<HR>
<H2><A NAME="MQSeries">MQSeries

</A></H2>
Supports explicit loading of MQClient::MQSeries or MQServer::MQSeries,
rather than implicit only.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Command">MQSeries::Command

</A></H2>
Introduce the Command Server API, for both PCF and MQSC command messages.


<P>

<P>
<HR>
<H2><A NAME="MQSeries_Message_Storable">MQSeries::Message::Storable

</A></H2>
Uses nfreeze, which is supposed to use network byte order, rather than
freeze.


<P>

<P>
<HR>
<H1><A NAME="Changes_for_1_03">Changes for 1.03

</A></H1>
<DL>
<DT><STRONG><A NAME="item_OO">OO API

</A></STRONG><DD>
First implementation of the OO portion of the API


<P>

<DT><STRONG>XS source

</A></STRONG><DD>
Eliminated the dual XS file templates, using one source for both V2 and V5


<P>

<DT><STRONG><A NAME="item_MQSeries">MQSeries core

</A></STRONG><DD>
Added two new utility functions to the core API:


<P>

<PRE>    MQParseEvent
    MQReasonToText
</PRE>

<P>

<DT><STRONG><A NAME="item_Locale">Locale hacks

</A></STRONG><DD>
MQSeries.pm will automagically set reasonable values for the LANG and
NLSPATH environment variables, if not set.


<P>

<DT><STRONG>Documentation

</A></STRONG><DD>
Significantly expanded documentation


<P>

</DL>
<P>
<HR>
<H1><A NAME="Changes_for_1_02">Changes for 1.02

</A></H1>
<DL>
<DT><STRONG><A NAME="item_Introduced">Introduced the extended test suite

</A></STRONG><DD>
<DT><STRONG><A NAME="item_Dual">Dual client/server support

</A></STRONG><DD>
Introduced the dual namespaces to make client vs. server usage transparent.
That is, MQSeries.pm really pulls in MQServer/MQSeries.pm on a queue
manager, and MQClient/MQSeries.pm otherwise.


<P>

<DT><STRONG><A NAME="item_PLMQ">PLMQ -> MQSeries

</A></STRONG><DD>
Change the module name from PLMQ to MQSeries, and changed the API calls
from GET to MQGET, etc., making the function mapping one to one.


<P>

<DT><STRONG><A NAME="item_typemap">typemap.PL

</A></STRONG><DD>
Automated the typemap generation using a typemap.PL file


<P>

</DL>
</DL>
    </BODY>

    </HTML>
